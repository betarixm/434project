# Architecture Proposal

## Problem Description

### Goal

Implementing system that can sort records stored across **multiple disks**, using **multiple machines** with **distributed/parallel** programming.

### Conditions

- Data
  - Records generated by [`gensort`](http://www.ordinal.com/gensort.html).
  - Each record consists of 10 bytes for the key and 90 bytes for the value.
- Resources
  - One master node and a fixed number of worker nodes.
- Input
  - Hosts and ports of workers.
  - A bunch of 32MB files allocated to each worker.
- Output
  - Ordered files with sorted data in each worker.

## Method

To fully exploiting the `N` number of workers, we should sort data in a distributed manner on each worker. To accomplish this, we propose dividing the entire procedure into two phases, as outlined below.

### First Phase: Relocating

To efficiently utilize all the workers for sorting, the master node assigns tasks to each worker based on key ranges and coordinates data exchange between them.

#### Step 1: Data Sampling

- Sample a small subset of records from each worker node.
- Send key of these samples to the master node.

#### Step 2: Key Range Estimation

- Master node sorts all the received keys.
- Master node then divide the sorted keys into `n` ranges, where `n` is the number of worker nodes.

#### Step 3: Broadcast Key Ranges

- Master node broadcasts the estimated key ranges to all worker nodes.

#### Step 4: Make Group(Partition)

- Each worker node then divides its local data according to the received key ranges.
- Any key falling within a particular range is grouped together.
- Detailed explanations for utilizing multiple cores can be found in the "Worker Proposal" document.

#### Step 5: Exchanging

- Master Node picks two worker nodes and changes its block until there is no further data to relocate.
  - `block`: the unit of moving data.
- For mor detailed explanations, please refer to the "Master Proposal" document.

#### Example

- Notation
  - `R[X]`: Key range of worker node `X`.
  - `D[X, Y]`: Roughly sorted data of range `R[Y]` in `X`, where `X` and `Y` are names of each worker.
- Suppose there are three worker nodes named `A`, `B`, and `C`.

1. Master node picks `A` and `B`.
1. Then `A` provides one block in `D[A, B]` to master node.
1. Then `B` gives one block in `D[B, A]` to master node.
1. Do this until there are no more blocks to relocate for both `A` and `B`.
1. Master node chooses `A` and `C`, then repeats steps 2-4.
1. Master node selects `B` and `C`, then repeats steps 2-4.

### Second Phase: Sorting

After data relocation, each worker node has its local data organized into partitions. In the second phase, all that needs to be done is sorting the data within each partition, automatically leading to overall sorting.

#### Step 1: Local Parallel Sorting

- Each worker performs merge sort in parallel with respect to other workers.
- Detailed explanations for utilizing multiple cores can be found in "Worker Proposal" document.

#### Step 2: Signaling Sorting Completion to Master Node

- Upon completing the sorting for all partitions, each worker node sends a signal to the master node indicating that it has finished sorting.
- The master node waits until all worker nodes gives signals to it.
- If all worker nodes signal master node, the program ends.

## More Detail

Until now, we got a big picture of achieving Goal, mainly about answering the question of "How to corrodinate Multiple Nodes?". The four Proposal document below will give you detailed explaination for each subject.

### Data Structure Proposal

- Define fundamental data structure that we will use through this project.

### RPC Protocol Proposal

- Data Sample Request and Reply
  - Master sends a request to each Worker.
  - Each Worker replies with a set of sample keys.
- Key Range Broadcast
  - Master broadcasts the key ranges to all Worker Nodes.
- Relocation Request and Reply
  - Master sends a request for data block movement.
  - Worker sends a reply the data block that will relocated.
- Sorting Complete Signal
  - Worker sends a signal to the Master.
  - Master keeps a count and waits for signals from all Workers.

### Worker Proposal

- Data Sampling
  - On request from the Master Node, the Worker sends back a small subset of records.
- Key Range Partitioning
  - Upon receiving key ranges, partition data based on those ranges.
  - Use parallelism
- Local Sorting
  - Perform merge sort on each partition.
  - Use parallelism
- Signalling
  - Once sorting is done, send a signal to the Master Node.

### Master Proposal

- Data Sampling
  - Request a set of sample records from each Worker Node.
- Key Range Estimation
  - Sort the keys and divide them into ranges.
- Key Range Broadcast
  - Broadcast the key ranges to all Worker Nodes.
- Block Relocation
  - Continuously pick two Workers and oversee the exchange of data blocks until there is nothing left to relocate.
- Waiting Mechanism
  - Wait for the signal from all Worker Nodes that they have completed sorting.
