# Architecture Proposal

## Problem Description

### Goal

Implementing system that can sort records stored across **multiple disks**, using **multiple machines** with **distributed/parallel** programming.

### Conditions

- Data
  - Records generated by [`gensort`](http://www.ordinal.com/gensort.html).
  - Each 100 bytes record consists of first 10 bytes for the key and remaining 90 bytes for the value.
- Resources
  - One master node and a fixed number of worker nodes.
- Input
  - Hosts and ports of workers.
  - A bunch of 32MB files allocated to each worker.
- Output
  - Ordered files with sorted data in each worker.

## Method

To fully exploiting the `N` number of workers, we should sort data in a distributed manner on each worker. To accomplish this, we propose dividing the entire procedure into two phases, as outlined below.

### First Phase: Relocating

To efficiently utilize all the workers for sorting, the master node assigns tasks to each worker based on key ranges and coordinates data exchange between them.

#### Step 1: Data Sampling

- Sample a small subset of records from each worker node.
- Send key of these samples to the master node.
  - We have to send sufficient number of keys, not to re-estimate the key ranges.
- Reason for sampling
  - There are multiple worker nodes independent of each other and we have to exploit all of the worker in parallel.
  - For each worker's meaningful sort, that leads to all system's sort, we have to allocate the range that worker will compute.
  - As we don't know the exact distribution of keys, this step is needed for allocating range of key to each worker.

#### Step 2: Key Range Estimation

- Master node sorts all the received keys.
- Master node then divide the sorted keys into `n` ranges, where `n` is the number of worker nodes.

#### Step 3: Broadcast Key Ranges

- Master node broadcasts the estimated key ranges to all worker nodes and waits for approved signal for each worker.

#### Step 4: Make Group(Partition)

- Master node signals each worker node to make group.
- Each worker node then divides its local data according to the received key ranges.
  - Any key falling within a particular range is grouped together.
- Detailed explanations for utilizing multiple cores can be found in the "Worker Proposal" document.

#### Step 5: Exchanging

- Master Node picks two worker nodes and changes its block until there is no further data to relocate.
  - `block`: the unit of moving data.
- For mor detailed explanations, please refer to the "Master Proposal" document.

##### Example

- Notation
  - `R[X]`: Key range of worker node `X`.
  - `D[X, Y]`: Roughly sorted data of range `R[Y]` in `X`, where `X` and `Y` are names of each worker.
- Suppose there are three worker nodes named `A`, `B`, and `C`.

1. Master node picks `A` and `B`.
1. Then `A` provides one block in `D[A, B]` to master node.
1. Then `B` gives one block in `D[B, A]` to master node.
1. Do this until there are no more blocks to relocate for both `A` and `B`.
1. Master node chooses `A` and `C`, then repeats steps 2-4.
1. Master node selects `B` and `C`, then repeats steps 2-4.

### Second Phase: Sorting

After data relocation, each worker node has its local data organized into partitions. In the second phase, all that needs to be done is sorting the data within each partition, automatically leading to overall sorting.

#### Step 1: Local Parallel Sorting

- Each worker performs merge sort in parallel with respect to other workers.
- Detailed explanations for utilizing multiple cores can be found in "Worker Proposal" document.

#### Step 2: Signaling Sorting Completion to Master Node

- Upon completing the sorting for all partitions, each worker node sends a signal to the master node indicating that it has finished sorting.
- The master node waits until all worker nodes gives signals to it.
- If all worker nodes signal master node, the program ends.

## More Details

So far, this document suggest a big picture to achieve our goal, mainly about answering the question of "How to Coordinate Multiple Nodes?". The four Proposal document below will provide detailed explanations for each subject.

### Data Structure Proposal

- Define fundamental data structure that we will use throughout this project.

### RPC Protocol Proposal

- Data Sample Request and Response
  - Master sends a request to each worker.
  - Each worker replies with a set of sample keys.
- Key Range Broadcast
  - Master broadcasts the key ranges to all worker nodes.
- Relocation Request and Response
  - Master sends a request for data block movement.
  - Worker sends a reply with the data block that will be relocated.
- Sorting Complete Signal
  - Worker sends a signal to the master.
  - Master keeps a count and waits for signals from all workers.

### Worker Proposal

- Data Sampling
  - On request from the master node, the worker sends back a small subset of records.
- Key Range Partitioning
  - Upon receiving key ranges, partition data based on those ranges and utilize parallelism
- Local Sorting
  - Perform merge sort on each partition using parallelism
- Signaling
  - Once sorting is completed, send a signal to the master node.

### Master Proposal

- Data Sampling
  - Request a set of sample records from each worker node.
- Key Range Estimation
  - Sort the keys and divide them into ranges.
- Key Range Broadcast
  - Broadcast the key ranges to all worker nodes.
- Block Relocation
  - Continuously select two workers and oversee the exchange of data blocks until there is nothing left to relocate.
- Waiting Mechanism
  - Wait for the signal from all worker nodes that they have completed sorting.
